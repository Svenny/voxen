#include <voxen/client/vulkan/common.hpp>

#include <voxen/client/vulkan/config.hpp>
#include <voxen/util/log.hpp>

#include <cassert>
#include <cstddef>
#include <malloc.h>

namespace
{

struct VulkanErrorCategory : std::error_category {
	const char *name() const noexcept override { return "Vulkan error"; }

	std::string message(int code) const override
	{
		return std::string(voxen::client::vulkan::VulkanUtils::getVkResultString(VkResult(code)));
	}
};

const VulkanErrorCategory g_category;

} // anonymous namespace

namespace std
{

error_condition make_error_condition(VkResult result) noexcept
{
	return { static_cast<int>(result), g_category };
}

} // namespace std

namespace voxen::client::vulkan
{

uint32_t VulkanUtils::alignUp(uint32_t size, uint32_t alignment) noexcept
{
	return (size + alignment - 1u) & ~(alignment - 1u);
}

uint64_t VulkanUtils::alignUp(uint64_t size, uint64_t alignment) noexcept
{
	return (size + alignment - 1u) & ~(alignment - 1u);
}

uint64_t VulkanUtils::calcFraction(uint64_t size, uint64_t numerator, uint64_t denomenator) noexcept
{
	return (size * numerator + denomenator - 1u) / denomenator;
}

VulkanException::VulkanException(VkResult result, std::string_view api, extras::source_location loc)
	: Exception(fmt::format("call to '{}' failed", api), std::make_error_condition(result), loc)
{
	assert(api.length() > 0);
	Log::error("{} failed with error code {}", api, VulkanUtils::getVkResultString(result), loc);
}

// Not defining inline to satisfy -Wweak-vtables
VulkanException::~VulkanException() noexcept = default;

VkResult VulkanException::result() const noexcept
{
	// We know the error category can only be vulkan one
	return static_cast<VkResult>(error().value());
}

std::string_view VulkanUtils::getVkResultString(VkResult result) noexcept
{
	using namespace std::string_view_literals;

#define CASE(err) \
	case err: \
		return #err##sv
	switch (result) {
	// Result codes
	CASE(VK_SUCCESS);
	CASE(VK_NOT_READY);
	CASE(VK_TIMEOUT);
	CASE(VK_EVENT_SET);
	CASE(VK_EVENT_RESET);
	CASE(VK_INCOMPLETE);
	CASE(VK_SUBOPTIMAL_KHR);
	CASE(VK_THREAD_IDLE_KHR);
	CASE(VK_THREAD_DONE_KHR);
	CASE(VK_OPERATION_DEFERRED_KHR);
	CASE(VK_OPERATION_NOT_DEFERRED_KHR);
	CASE(VK_PIPELINE_COMPILE_REQUIRED);
	// Error codes
	CASE(VK_ERROR_OUT_OF_HOST_MEMORY);
	CASE(VK_ERROR_OUT_OF_DEVICE_MEMORY);
	CASE(VK_ERROR_INITIALIZATION_FAILED);
	CASE(VK_ERROR_DEVICE_LOST);
	CASE(VK_ERROR_MEMORY_MAP_FAILED);
	CASE(VK_ERROR_LAYER_NOT_PRESENT);
	CASE(VK_ERROR_EXTENSION_NOT_PRESENT);
	CASE(VK_ERROR_FEATURE_NOT_PRESENT);
	CASE(VK_ERROR_INCOMPATIBLE_DRIVER);
	CASE(VK_ERROR_TOO_MANY_OBJECTS);
	CASE(VK_ERROR_FORMAT_NOT_SUPPORTED);
	CASE(VK_ERROR_FRAGMENTED_POOL);
	CASE(VK_ERROR_UNKNOWN);
	CASE(VK_ERROR_OUT_OF_POOL_MEMORY);
	CASE(VK_ERROR_INVALID_EXTERNAL_HANDLE);
	CASE(VK_ERROR_FRAGMENTATION);
	CASE(VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS);
	CASE(VK_ERROR_SURFACE_LOST_KHR);
	CASE(VK_ERROR_NATIVE_WINDOW_IN_USE_KHR);
	CASE(VK_ERROR_OUT_OF_DATE_KHR);
	CASE(VK_ERROR_INCOMPATIBLE_DISPLAY_KHR);
	CASE(VK_ERROR_VALIDATION_FAILED_EXT);
	CASE(VK_ERROR_INVALID_SHADER_NV);
	CASE(VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT);
	CASE(VK_ERROR_NOT_PERMITTED_KHR);
	CASE(VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT);
	CASE(VK_ERROR_COMPRESSION_EXHAUSTED_EXT);
	CASE(VK_INCOMPATIBLE_SHADER_BINARY_EXT);
	CASE(VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR);
	CASE(VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR);
	// Just to satisfy -Wswitch
	CASE(VK_RESULT_MAX_ENUM);
	} // No `default` to make `-Werror -Wswitch` protection work
#undef CASE
}

std::string_view VulkanUtils::getVkFormatString(VkFormat format) noexcept
{
	using namespace std::string_view_literals;

	// The list is copy-pasted from Vulkan 1.2.170 headers.
	// Multiplane, some block, 4-bit, scaled and other crazy formats were removed.
#define CASE(fmt) \
	case fmt: \
		return #fmt##sv
	switch (format) {
	CASE(VK_FORMAT_UNDEFINED);
	CASE(VK_FORMAT_R8_UNORM);
	CASE(VK_FORMAT_R8_SNORM);
	CASE(VK_FORMAT_R8_UINT);
	CASE(VK_FORMAT_R8_SINT);
	CASE(VK_FORMAT_R8_SRGB);
	CASE(VK_FORMAT_R8G8_UNORM);
	CASE(VK_FORMAT_R8G8_SNORM);
	CASE(VK_FORMAT_R8G8_UINT);
	CASE(VK_FORMAT_R8G8_SINT);
	CASE(VK_FORMAT_R8G8_SRGB);
	CASE(VK_FORMAT_R8G8B8_UNORM);
	CASE(VK_FORMAT_R8G8B8_SNORM);
	CASE(VK_FORMAT_R8G8B8_UINT);
	CASE(VK_FORMAT_R8G8B8_SINT);
	CASE(VK_FORMAT_R8G8B8_SRGB);
	CASE(VK_FORMAT_B8G8R8_UNORM);
	CASE(VK_FORMAT_B8G8R8_SNORM);
	CASE(VK_FORMAT_B8G8R8_UINT);
	CASE(VK_FORMAT_B8G8R8_SINT);
	CASE(VK_FORMAT_B8G8R8_SRGB);
	CASE(VK_FORMAT_R8G8B8A8_UNORM);
	CASE(VK_FORMAT_R8G8B8A8_SNORM);
	CASE(VK_FORMAT_R8G8B8A8_UINT);
	CASE(VK_FORMAT_R8G8B8A8_SINT);
	CASE(VK_FORMAT_R8G8B8A8_SRGB);
	CASE(VK_FORMAT_B8G8R8A8_UNORM);
	CASE(VK_FORMAT_B8G8R8A8_SNORM);
	CASE(VK_FORMAT_B8G8R8A8_UINT);
	CASE(VK_FORMAT_B8G8R8A8_SINT);
	CASE(VK_FORMAT_B8G8R8A8_SRGB);
	CASE(VK_FORMAT_A8B8G8R8_UNORM_PACK32);
	CASE(VK_FORMAT_A8B8G8R8_SNORM_PACK32);
	CASE(VK_FORMAT_A8B8G8R8_UINT_PACK32);
	CASE(VK_FORMAT_A8B8G8R8_SINT_PACK32);
	CASE(VK_FORMAT_A8B8G8R8_SRGB_PACK32);
	CASE(VK_FORMAT_A2R10G10B10_UNORM_PACK32);
	CASE(VK_FORMAT_A2R10G10B10_SNORM_PACK32);
	CASE(VK_FORMAT_A2R10G10B10_UINT_PACK32);
	CASE(VK_FORMAT_A2R10G10B10_SINT_PACK32);
	CASE(VK_FORMAT_A2B10G10R10_UNORM_PACK32);
	CASE(VK_FORMAT_A2B10G10R10_SNORM_PACK32);
	CASE(VK_FORMAT_A2B10G10R10_UINT_PACK32);
	CASE(VK_FORMAT_A2B10G10R10_SINT_PACK32);
	CASE(VK_FORMAT_R16_UNORM);
	CASE(VK_FORMAT_R16_SNORM);
	CASE(VK_FORMAT_R16_UINT);
	CASE(VK_FORMAT_R16_SINT);
	CASE(VK_FORMAT_R16_SFLOAT);
	CASE(VK_FORMAT_R16G16_UNORM);
	CASE(VK_FORMAT_R16G16_SNORM);
	CASE(VK_FORMAT_R16G16_UINT);
	CASE(VK_FORMAT_R16G16_SINT);
	CASE(VK_FORMAT_R16G16_SFLOAT);
	CASE(VK_FORMAT_R16G16B16_UNORM);
	CASE(VK_FORMAT_R16G16B16_SNORM);
	CASE(VK_FORMAT_R16G16B16_USCALED);
	CASE(VK_FORMAT_R16G16B16_SSCALED);
	CASE(VK_FORMAT_R16G16B16_UINT);
	CASE(VK_FORMAT_R16G16B16_SINT);
	CASE(VK_FORMAT_R16G16B16_SFLOAT);
	CASE(VK_FORMAT_R16G16B16A16_UNORM);
	CASE(VK_FORMAT_R16G16B16A16_SNORM);
	CASE(VK_FORMAT_R16G16B16A16_USCALED);
	CASE(VK_FORMAT_R16G16B16A16_SSCALED);
	CASE(VK_FORMAT_R16G16B16A16_UINT);
	CASE(VK_FORMAT_R16G16B16A16_SINT);
	CASE(VK_FORMAT_R16G16B16A16_SFLOAT);
	CASE(VK_FORMAT_R32_UINT);
	CASE(VK_FORMAT_R32_SINT);
	CASE(VK_FORMAT_R32_SFLOAT);
	CASE(VK_FORMAT_R32G32_UINT);
	CASE(VK_FORMAT_R32G32_SINT);
	CASE(VK_FORMAT_R32G32_SFLOAT);
	CASE(VK_FORMAT_R32G32B32_UINT);
	CASE(VK_FORMAT_R32G32B32_SINT);
	CASE(VK_FORMAT_R32G32B32_SFLOAT);
	CASE(VK_FORMAT_R32G32B32A32_UINT);
	CASE(VK_FORMAT_R32G32B32A32_SINT);
	CASE(VK_FORMAT_R32G32B32A32_SFLOAT);
	CASE(VK_FORMAT_D16_UNORM);
	CASE(VK_FORMAT_X8_D24_UNORM_PACK32);
	CASE(VK_FORMAT_D32_SFLOAT);
	CASE(VK_FORMAT_S8_UINT);
	CASE(VK_FORMAT_D16_UNORM_S8_UINT);
	CASE(VK_FORMAT_D24_UNORM_S8_UINT);
	CASE(VK_FORMAT_D32_SFLOAT_S8_UINT);
	CASE(VK_FORMAT_BC1_RGB_UNORM_BLOCK);
	CASE(VK_FORMAT_BC1_RGB_SRGB_BLOCK);
	CASE(VK_FORMAT_BC1_RGBA_UNORM_BLOCK);
	CASE(VK_FORMAT_BC1_RGBA_SRGB_BLOCK);
	CASE(VK_FORMAT_BC2_UNORM_BLOCK);
	CASE(VK_FORMAT_BC2_SRGB_BLOCK);
	CASE(VK_FORMAT_BC3_UNORM_BLOCK);
	CASE(VK_FORMAT_BC3_SRGB_BLOCK);
	CASE(VK_FORMAT_BC4_UNORM_BLOCK);
	CASE(VK_FORMAT_BC4_SNORM_BLOCK);
	CASE(VK_FORMAT_BC5_UNORM_BLOCK);
	CASE(VK_FORMAT_BC5_SNORM_BLOCK);
	CASE(VK_FORMAT_BC6H_UFLOAT_BLOCK);
	CASE(VK_FORMAT_BC6H_SFLOAT_BLOCK);
	CASE(VK_FORMAT_BC7_UNORM_BLOCK);
	CASE(VK_FORMAT_BC7_SRGB_BLOCK);
	// Too many formats to omit `default` for `-Wswitch` protection
	default:
		return "VK_FORMAT_[UNKNOWN]"sv;
	}
#undef CASE
}

bool VulkanUtils::hasStencilComponent(VkFormat format) noexcept
{
	return format == VK_FORMAT_S8_UINT || format == VK_FORMAT_D16_UNORM_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT
		|| format == VK_FORMAT_D32_SFLOAT_S8_UINT;
}

} // namespace voxen::client::vulkan
